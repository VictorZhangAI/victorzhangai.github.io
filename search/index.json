[{"content":"单调栈 栈中元素从栈顶到栈底依次递增\n一个新数字进栈前要弹出所有比它小的数，所有数字都入栈\n例题：洛谷P2947\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int h[100000], ans[100000]; int main() { stack\u0026lt;int\u0026gt; s; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); } for(int i = n; i \u0026gt;= 1; i--) { while(!s.empty() \u0026amp;\u0026amp; h[s.top()] \u0026lt;= h[i]) s.pop(); if(s.empty()) ans[i] = 0; else ans[i] = s.top(); s.push(i); } for(int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } 哈夫曼编码 例题：poj 1521\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; string s; while(getline(cin, s) \u0026amp;\u0026amp; s != \u0026#34;END\u0026#34;) { sort(s.begin(), s.end()); int num = 1; for(int i = 1; i \u0026lt;= s.length(); i++) { if(s[i] != s[i - 1]) { q.push(num); num = 1; } else num++; } int ans = 0; if(q.size() == 1) ans = s.length(); while(q.size() \u0026gt; 1) { int a = q.top(); q.pop(); int b = q.top(); q.pop(); q.push(a + b); ans += a + b; } q.pop(); printf(\u0026#34;%d %d %.1f\\n\u0026#34;, s.length() * 8, ans, (double)s.length() * 8 / (double)ans); } return 0; } 优先队列与堆 使用priority_queue可以避免手动管理堆的实现代码\n例题：洛谷P3378\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); q.push(x); } else if(op == 2) { printf(\u0026#34;%d\\n\u0026#34;, q.top()); } else q.pop(); } return 0; } 重点是中间的priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q;\n","date":"2024-12-11T10:17:29+08:00","permalink":"https://victorzhangai.github.io/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"《算法竞赛》第一章笔记"},{"content":"单周期处理器（LA版本） 延迟槽：曾几何时它很好，然而它非但无法解决延迟造成的流水线阻塞问题，而且会使微结构的设计复杂化，而且编译器并不能总是提取出有效指令填入流水线导致流水线中出现过量空指令，影响流水线性能\n支持远距离跳转的指令集可以更好减少由于代码体积增大而产生的效率降低问题\n跳转后还要从寄存器中获得对应的地址，故称间接跳转，link用于返回地址的链接\n去掉unsigned的指令集依然是完整的\n至少需要一条syscall才能使用操作系统，否则指令集无法区分用户态和核心态\n务必注意当input的取值是最后一个值的时候的output\nCPU = 数据通路 + 控制逻辑\n指令在指令存储器中存储，地址为PC\n每执行完一条指令，PC = PC + 4\n指令存储器是一个静态存储器，所有写的端口恒为0\nadd.w: 从寄存器堆读取操作数，相加，写回寄存器堆\n寄存器堆的读端口必须有两个，否则执行add需要两个周期；而写端口要有enable（或者reset）\naddi.w: 与add.w唯一的区别就是第二个源操作数来自指令集中立即数符号扩展至32位\nld.w可以复用addi.w的数据通路，ld.w从从数据存储器中读取数据，取回的数据与加法器结果二选一放入寄存器堆\nst.w写数据存储器，不写寄存器堆\n务必注意：st.w的源操作数来自rd域，因为增加一个读端口会增加硬件开销\ndest bne = PC + offset\nbne根据判断的结果决定是否跳转\n每次加指令时进行的检查：本条指令是否正确运行，已有的指令功能是否正常\nzero寄存器的作用就是减少实现指令集子集时的xor\n编写控制信号的真值表\n存储器本质上属于核外单元，一些实际的案例中CPU的最顶层只有CLK和RESET\n现如今的EDA几乎可以把电路性能优化到极致，所以要以可读性与可维护性作为更高的目标\n不要写真值表，画卡诺图，直接对照指令的机器码格式和电路图敲Verilog\n多一条assign可以提高代码可读性\nb: 立即数增宽至26位\nbl:b之后将PC + 4写入r1（单周期甚至可以直接拉线到MUX写入）\n新增的控制信号依然要考虑所有的指令\n","date":"2024-12-10T16:55:17+08:00","permalink":"https://victorzhangai.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8la%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/","title":"单周期处理器（LA）讲座笔记"},{"content":"（注：这篇文章成文于一年前，放在博客上只是为了留档）\n最开始接触这玩意儿其实是因为前端（一朝做贼，再想做好人可不容易啊），菜鸟教程推荐的编辑器里头有VSCode，Sublime和WebStorm，这仨里头VSC配C的环境给我配出心理阴影了，而且这玩意儿甚至原生不支持ctrl+滚轮缩放字体。WS要钱，一年两千八，我说我别tm做个前端还得贴钱打工，于是选了Sublime，不得不承认这玩意儿确实好使得一批，现在除了C，Python和Mathematica直接Sublime+命令行，真正做到了有高亮有编译器就能写。\n这篇文章的内容全部为个人总结，毕竟网上能找到的Sublime教程都挺乐色的。\n基本使用方法 下载的话直接下就行，这玩意儿反正免费，不过保存文件的时候会时不时蹦个小窗口要你买License，有点烦人，不必管它。\n建议使用原生英文环境，毕竟那几个单词也不难，中文得装包，而且多语言包其实不好用，有一些词语原来是英文到头还是英文。\n双击快捷方式进入，View，SideBar，Show SideBar，调出来侧边栏，这样你就能看到你打开的文件。\nFile，New File可以新创建一个文件（注意这个文件是缺少后缀的），Open File可以打开一个文件并自动匹配高亮。\nNew File之后的第一件事务必先View，Syntax里头找这个语言的高亮，这不仅可以给你敲代码带来方便还能为你的代码文件添加对应的后缀（比如C的.c，Python的.py）\n一些关键字，头文件和函数会有对应的联想，如果想使用这些联想（或者叫补全）就即使按下Tab应用。\n敲完代码后ctrl+S保存\n高级技巧（也许？） ctrl+shift+P会打开一个搜索框，输入install，找到PackageInstaller就可以安装一些包让你的sublime变得花里胡哨。\n卸载Package输入remove即可\n比如你想要某个语言的高亮而Syntax找不见的时候就可以搜索这个语言的名称安装高亮和文件后缀支持。 搜索Chinese可以找到多语言支持不过不好使。 Emmet，直到我从前端滚蛋了四个月我才装这个包\nctrl+F在文件中进行搜索\n左手双指滑动右手按住鼠标就可以控制选中文本的速度，适用于没怎么学快捷键而单用鼠标控制不住文本选择的人\nctrl+P添加//注释\nctrl+shift+P添加/* 注释* /\nctrl+F 全局查找对应关键词\n至于其他的快捷键可以直接搜索对应关键词，不过我没咋用过别的快捷键就是了\nEdit里的Undo和Redo可以用来吃后悔药\n没保存也没关系，Sublime的逻辑是打开后自动开启上个工作文件的已有进程\n每行旁边如果有个倒三角可以进行代码缩略（常见于函数和CSS样式表）（这玩意儿在编CSS的时候救了我的老命要不然眼睛迟早得完蛋）\n右侧的代码预览可以快速转移至文件的某处代码\n环境变量中添加\u0026hellip;\u0026hellip;\\Sublime Text后可以使用Sublime的shell命令\nsubl 直接打开\nsubl 文件名 新建文件（Sublime直至你指定前不进行文件保存工作）\n","date":"2024-12-10T16:52:35+08:00","permalink":"https://victorzhangai.github.io/p/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8Bsublime/","title":"一分钟上手Sublime"},{"content":"4.1 prelude PC holds the address of the instruction that currently executed.\nregisters, base pointer, stack pointer\ncondition code: ZF, SF, OF\nmemory(monolithic byte array)\nTypes of encoding the Y-86 instructions:\nI-type, D-type and B-type\ninstructions movq is split: I, R, M -\u0026gt; R, M\nAL instructions: addq, subq, andq, xorq (as there is no zero register in Y-86 processor, you must add an xorq instruction)\njumps: jmp, \u0026lt;=, \u0026lt;, ==, !=, \u0026gt;=, \u0026gt;\ncond move: \u0026lt;=, \u0026lt;, ==, !=, \u0026gt;=, \u0026gt;\nhalt: stops the program\nencode code + function\nstore in a small RAM\nno ambiguity when encoding the instructions\nY86-64 is CISC-like for its various length of instructions and RISC-like for its single load/store encoding\nexceptions AOK, HLT, ADR, INS\nshut whenever not AOK\nrun a code addq needs another register but subq can also set the stat code\npushq and popq\u0026rsquo;s details may largely reduce the code portability, problem may occur when subq compares rsp and the pushed value, or pop the stack pointer, undefined behavior always annoy people anytime anywhere.\n4.2 components combinational logic, memory elements, clock signals(sequential logic is split into two parts)\nsimilarity: Verilog -\u0026gt; C, VHDL -\u0026gt; Ada\nHCL == block:\nbool eq = (a \u0026amp;\u0026amp; b) || (!a \u0026amp;\u0026amp; !b)\nHCL MUX block:\nbool out = (s \u0026amp;\u0026amp; a) || ()\nword level: using cases\n1 2 3 4 word Out = [ s: A; 1: B; ]; sequential logic reg \u0026amp; RAM\nstate changes only when clock rises\nsimple regfile:\nvalA, valB, srcA, srcB, dstW, valW\nin the Y86 processor: a memory with 2 ports, one for R inst, the other for R/W data\n4.3 stages of instructions Fetch PC = memaddr\nvalP = PC + len(inst)\nDecode read operands from reg file\nExecute ALU performs instruction or incr/decr the stack pointer, for other instruction, similar\nMemory W/R data in mem\nWrite back write back to register\nPC update PC stores addr of next instruction\ncost of adding hardware \u0026gt; cost of copying code in software\nprocess similar instructions in same manners\nHardware Fetch: PC computes valP, the incremented PC.\nDecode: read valA and valB\nExecute: ALU calculates integer or increments the stack pointer, decides whether jump or not.\nMemory: read or write a word of mem\nWrite Back: write back from ALU or mem\nPC update\nonly start next cycle when clock rises\nprocessor never read back\neg: no instruction will both set and read the cond code\neg: stack pointer\nfetch: fetching 6 bytes and generate instruction fields.\ndecode \u0026amp; write back: generate register identifiers, serve necessary data.\nexecute: ALU performs as the calculator or just the adder.\nmemory: write or read memory values.\nPC increment: depend on instruction code or branch or not.\nSurvey the clock must run slow enough to suit the single-cycle.\nthe parts of the processor only active for a single part of time in the clock cycle\n4.4 pipelining divide into a series of discrete stages\nincrease the throughput of a system, but slightly increase the latency\nnonpipelined: a logic performs the computation with a register hold the result of the computation\nlatency: the total time to perform a single instruction\nslowing the clock won\u0026rsquo;t change the behavior of a pipeline.\ndifferent clock delays of different instructions influences the pipeline,\ndue to the delay, pipeline doesn\u0026rsquo;t always have larger throughput with more stages on each instruction\nlogical dependencies limits the performance of pipeline\n","date":"2024-12-10T16:44:47+08:00","permalink":"https://victorzhangai.github.io/p/csapp-chapter4/","title":"Csapp Chapter4"},{"content":"VZstless as your friend or thinker 🍥 Call this name as VictorZhang was signed up by somebody else\u0026hellip;\n👻 Love frontend in any perspective, digital, or web.\n🐣 Libre \u0026amp; OpenSource aholic.\n⭐ Still an undergraduate and a crazyone.\n🐧 A human-like history book or cheatsheet.\n✉️ 2319725508@qq.com\n🍀I work so I live.\nblog\n","date":"2024-12-09T20:45:32+08:00","permalink":"https://victorzhangai.github.io/p/whoami/","title":"Whoami"}]