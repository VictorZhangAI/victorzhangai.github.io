[{"content":"事先声明，锐评不代表讨厌，相反，正是因为你有了足够的了解之后你才能知道为啥人家的课程好，我们的为什么烂。我感谢它们，在无数节水课中带我消磨时间，做有趣的事情。\nSICP SICP这个课可就有点儿历史了，上世纪80年代，Abelson和Sussman这俩人用他们编写的教科书改造了MIT的计算机入门课程。它主要使用Lisp的一门方言——MIT Scheme进行编程，讲解关于计算机思维与计算方法的基础知识。现在网上流传的始祖SICP实质上是两个教授去惠普公司进行的讲座，不过内容大同小异就是了。说是基础，但是这个课联同这本书都是极其折磨的。\n首先，Scheme，或者说Lisp系的语言只能写递归不能写迭代。这门课程的起初就在不断地教你如何递归展开。随后便是一些时至今日也在使用的编程语言设计理念的雏形——数据结构，面向对象，流，乃至并发。不要用你学某个现代化程度很高的编程语言的经验简单套用在这里，Lisp的bare metal程度某种意义上不亚于C，许多的现有的知识要先有一层抽象才能转化成Lisp的东西。以及这本书会大量地造轮子。造图片编程语言，造小型SQL，造基于Lisp-Like汇编语言的寄存器机器。对，某种意义上你现有的对于计算机的知识都被颠覆了，这本书告诉你只要有了Lisp你能造出来所有东西！\n当时学的时候我用了先看课再看书的策略，结果发现书上的题目和前头的知识完全就是雕花和切冻肉的关系（笑）。经常有第一题“来，仿照那个加法程序造一个乘法程序”，第二题“来，刚才用迭代写的同学转化成递归来写，刚才用递归的同学用迭代来写！”，第三题“你看，加法和乘法可以抽象成XXX，这个程序怎么写呢？”，第四题又是迭代换递归，递归换迭代，第五题又再抽象一层，抽象到最后还不忘问你一句“嘿，你觉得你的设计真的合理吗？”，绝大多数情况下我做到第三题就破大防去抄答案了。\n第四章和第五章虽说是讲evaluator，SQL和寄存器机器这种显而易见的东西，但是在书里头这玩意儿又被一层又一层抽象了。后来我转念一想“估计这点儿玩意儿我这辈子都用不上了”，就去做了一下“Build your own Lisp”，把第四章和第五章的课程录像看完了就跑了。\n现在想想UCB和MIT把这个课程改成Python，SQL和Lisp真是明智的选择。他们从函数入手而不是递归，大大降低了这门课程的门槛，第四章原来的造轮子变成了摆在眼前的SQL，之于更高层次的抽象则交给了Lisp。Sussman曾经暗讽过这个课程改变是让人做脱离系统的调包侠，但是调包不也是优化程序的一种有效手段吗？何况这个课程的教授方式也大变了，先让你熟悉终端，相关硬件的下载和从网站上获取压缩包。这个知识屏蔽已经到极致了。没有git，没有链接，没有过于繁杂的命令行，总之个人认为这个课程进步了很多。\n有人会问推不推荐学CS61A，我说你要是大佬休闲想学学无所谓。至于老版的SICP和配套的那本书，实在话，还是直接进入历史的故纸堆就好。我读过了，不建议你走同样的路。顺带一提，负责原始版本SICP翻译的HIT IBM俱乐部今日也某种意义上“半死不活”了。\nAlgorithms 最初接触这玩意儿的时候是我淘书的时候发现的人民邮电出版社的中译本，“与TAOCP相媲美的神作”，豁，那可得看看咯。结果第一章就看不懂了，作者居然自己搓了个Java标准库用，还得自己配，然后就是极其痛苦的配环境，最后环境没弄成，这本书就吃灰了。\n后来听人说Sedgewick的课比书好，我就去看课，看完就用C++尝试把示例代码重构了。但是有一整章的代码我都重构失败了，就是图算法。这本书绝大多数的代码都依赖于作者自己搓的标准库中的API，这就导致图算法重构的时候源代码毫无参考性，你就只能去诸如OI wiki的地方寻找。我严重怀疑这个所谓的“抽象数据结构”的思想给国内诸如严蔚敏《数据结构》一类的差评如潮的教材开了个坏头。如果我都无法将你的算法思维进行有效的迁移，那你这个课又有什么用呢？\n有！确切来讲是另一种意义上的。这门课会告诉你专业人士是怎么研究算法的。而且这个课很“新”。2007年Sedgewick将Red-Black BST进行了简化，变成了LLRB-BST，2012年，这个研究就被写入了教材。某种意义上这门课程给了你一种“这个算法牛逼吗？我发明的！”的一种震撼。\n于你而言这门课其实只需要看四个地方：开头的并查集优化，快速排序在大量重复关键字下的优化，左斜红黑树和3-Way Trie。这几个算法各有特色，而且有Sedgewick教授的原创成分。相信我，当你看见demo中的红黑树就像被赋予生命了一样自动平衡的时候你会发自内心大吼一句“卧槽”的。\n","date":"2024-12-15T13:38:47+08:00","permalink":"https://victorzhangai.github.io/p/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%BD%91%E7%BB%9C%E7%83%AD%E9%97%A8%E8%AF%BE%E7%A8%8B/","title":"关于一些网络热门课程"},{"content":"单调栈 栈中元素从栈顶到栈底依次递增\n一个新数字进栈前要弹出所有比它小的数，所有数字都入栈\n例题：洛谷P2947\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int h[100000], ans[100000]; int main() { stack\u0026lt;int\u0026gt; s; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); } for(int i = n; i \u0026gt;= 1; i--) { while(!s.empty() \u0026amp;\u0026amp; h[s.top()] \u0026lt;= h[i]) s.pop(); if(s.empty()) ans[i] = 0; else ans[i] = s.top(); s.push(i); } for(int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } 哈夫曼编码 例题：poj 1521\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; string s; while(getline(cin, s) \u0026amp;\u0026amp; s != \u0026#34;END\u0026#34;) { sort(s.begin(), s.end()); int num = 1; for(int i = 1; i \u0026lt;= s.length(); i++) { if(s[i] != s[i - 1]) { q.push(num); num = 1; } else num++; } int ans = 0; if(q.size() == 1) ans = s.length(); while(q.size() \u0026gt; 1) { int a = q.top(); q.pop(); int b = q.top(); q.pop(); q.push(a + b); ans += a + b; } q.pop(); printf(\u0026#34;%d %d %.1f\\n\u0026#34;, s.length() * 8, ans, (double)s.length() * 8 / (double)ans); } return 0; } 优先队列与堆 使用priority_queue可以避免手动管理堆的实现代码\n例题：洛谷P3378\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n--) { int op; scanf(\u0026#34;%d\u0026#34;, \u0026amp;op); if(op == 1) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); q.push(x); } else if(op == 2) { printf(\u0026#34;%d\\n\u0026#34;, q.top()); } else q.pop(); } return 0; } 重点是中间的priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q;\n","date":"2024-12-11T10:17:29+08:00","permalink":"https://victorzhangai.github.io/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"《算法竞赛》第一章笔记"},{"content":"单周期处理器（LA版本） 延迟槽：曾几何时它很好，然而它非但无法解决延迟造成的流水线阻塞问题，而且会使微结构的设计复杂化，而且编译器并不能总是提取出有效指令填入流水线导致流水线中出现过量空指令，影响流水线性能\n支持远距离跳转的指令集可以更好减少由于代码体积增大而产生的效率降低问题\n跳转后还要从寄存器中获得对应的地址，故称间接跳转，link用于返回地址的链接\n去掉unsigned的指令集依然是完整的\n至少需要一条syscall才能使用操作系统，否则指令集无法区分用户态和核心态\n务必注意当input的取值是最后一个值的时候的output\nCPU = 数据通路 + 控制逻辑\n指令在指令存储器中存储，地址为PC\n每执行完一条指令，PC = PC + 4\n指令存储器是一个静态存储器，所有写的端口恒为0\nadd.w: 从寄存器堆读取操作数，相加，写回寄存器堆\n寄存器堆的读端口必须有两个，否则执行add需要两个周期；而写端口要有enable（或者reset）\naddi.w: 与add.w唯一的区别就是第二个源操作数来自指令集中立即数符号扩展至32位\nld.w可以复用addi.w的数据通路，ld.w从从数据存储器中读取数据，取回的数据与加法器结果二选一放入寄存器堆\nst.w写数据存储器，不写寄存器堆\n务必注意：st.w的源操作数来自rd域，因为增加一个读端口会增加硬件开销\ndest bne = PC + offset\nbne根据判断的结果决定是否跳转\n每次加指令时进行的检查：本条指令是否正确运行，已有的指令功能是否正常\nzero寄存器的作用就是减少实现指令集子集时的xor\n编写控制信号的真值表\n存储器本质上属于核外单元，一些实际的案例中CPU的最顶层只有CLK和RESET\n现如今的EDA几乎可以把电路性能优化到极致，所以要以可读性与可维护性作为更高的目标\n不要写真值表，画卡诺图，直接对照指令的机器码格式和电路图敲Verilog\n多一条assign可以提高代码可读性\nb: 立即数增宽至26位\nbl:b之后将PC + 4写入r1（单周期甚至可以直接拉线到MUX写入）\n新增的控制信号依然要考虑所有的指令\n","date":"2024-12-10T16:55:17+08:00","permalink":"https://victorzhangai.github.io/p/%E5%8D%95%E5%91%A8%E6%9C%9F%E5%A4%84%E7%90%86%E5%99%A8la%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/","title":"单周期处理器（LA）讲座笔记"},{"content":"（注：这篇文章成文于一年前，放在博客上只是为了留档）\n最开始接触这玩意儿其实是因为前端（一朝做贼，再想做好人可不容易啊），菜鸟教程推荐的编辑器里头有VSCode，Sublime和WebStorm，这仨里头VSC配C的环境给我配出心理阴影了，而且这玩意儿甚至原生不支持ctrl+滚轮缩放字体。WS要钱，一年两千八，我说我别tm做个前端还得贴钱打工，于是选了Sublime，不得不承认这玩意儿确实好使得一批，现在除了C，Python和Mathematica直接Sublime+命令行，真正做到了有高亮有编译器就能写。\n这篇文章的内容全部为个人总结，毕竟网上能找到的Sublime教程都挺乐色的。\n基本使用方法 下载的话直接下就行，这玩意儿反正免费，不过保存文件的时候会时不时蹦个小窗口要你买License，有点烦人，不必管它。\n建议使用原生英文环境，毕竟那几个单词也不难，中文得装包，而且多语言包其实不好用，有一些词语原来是英文到头还是英文。\n双击快捷方式进入，View，SideBar，Show SideBar，调出来侧边栏，这样你就能看到你打开的文件。\nFile，New File可以新创建一个文件（注意这个文件是缺少后缀的），Open File可以打开一个文件并自动匹配高亮。\nNew File之后的第一件事务必先View，Syntax里头找这个语言的高亮，这不仅可以给你敲代码带来方便还能为你的代码文件添加对应的后缀（比如C的.c，Python的.py）\n一些关键字，头文件和函数会有对应的联想，如果想使用这些联想（或者叫补全）就即使按下Tab应用。\n敲完代码后ctrl+S保存\n高级技巧（也许？） ctrl+shift+P会打开一个搜索框，输入install，找到PackageInstaller就可以安装一些包让你的sublime变得花里胡哨。\n卸载Package输入remove即可\n比如你想要某个语言的高亮而Syntax找不见的时候就可以搜索这个语言的名称安装高亮和文件后缀支持。 搜索Chinese可以找到多语言支持不过不好使。 Emmet，直到我从前端滚蛋了四个月我才装这个包\nctrl+F在文件中进行搜索\n左手双指滑动右手按住鼠标就可以控制选中文本的速度，适用于没怎么学快捷键而单用鼠标控制不住文本选择的人\nctrl+P添加//注释\nctrl+shift+P添加/* 注释* /\nctrl+F 全局查找对应关键词\n至于其他的快捷键可以直接搜索对应关键词，不过我没咋用过别的快捷键就是了\nEdit里的Undo和Redo可以用来吃后悔药\n没保存也没关系，Sublime的逻辑是打开后自动开启上个工作文件的已有进程\n每行旁边如果有个倒三角可以进行代码缩略（常见于函数和CSS样式表）（这玩意儿在编CSS的时候救了我的老命要不然眼睛迟早得完蛋）\n右侧的代码预览可以快速转移至文件的某处代码\n环境变量中添加\u0026hellip;\u0026hellip;\\Sublime Text后可以使用Sublime的shell命令\nsubl 直接打开\nsubl 文件名 新建文件（Sublime直至你指定前不进行文件保存工作）\n","date":"2024-12-10T16:52:35+08:00","permalink":"https://victorzhangai.github.io/p/%E4%B8%80%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8Bsublime/","title":"一分钟上手Sublime"},{"content":"4.1 prelude PC holds the address of the instruction that currently executed.\nregisters, base pointer, stack pointer\ncondition code: ZF, SF, OF\nmemory(monolithic byte array)\nTypes of encoding the Y-86 instructions:\nI-type, D-type and B-type\ninstructions movq is split: I, R, M -\u0026gt; R, M\nAL instructions: addq, subq, andq, xorq (as there is no zero register in Y-86 processor, you must add an xorq instruction)\njumps: jmp, \u0026lt;=, \u0026lt;, ==, !=, \u0026gt;=, \u0026gt;\ncond move: \u0026lt;=, \u0026lt;, ==, !=, \u0026gt;=, \u0026gt;\nhalt: stops the program\nencode code + function\nstore in a small RAM\nno ambiguity when encoding the instructions\nY86-64 is CISC-like for its various length of instructions and RISC-like for its single load/store encoding\nexceptions AOK, HLT, ADR, INS\nshut whenever not AOK\nrun a code addq needs another register but subq can also set the stat code\npushq and popq\u0026rsquo;s details may largely reduce the code portability, problem may occur when subq compares rsp and the pushed value, or pop the stack pointer, undefined behavior always annoy people anytime anywhere.\n4.2 components combinational logic, memory elements, clock signals(sequential logic is split into two parts)\nsimilarity: Verilog -\u0026gt; C, VHDL -\u0026gt; Ada\nHCL == block:\nbool eq = (a \u0026amp;\u0026amp; b) || (!a \u0026amp;\u0026amp; !b)\nHCL MUX block:\nbool out = (s \u0026amp;\u0026amp; a) || ()\nword level: using cases\n1 2 3 4 word Out = [ s: A; 1: B; ]; sequential logic reg \u0026amp; RAM\nstate changes only when clock rises\nsimple regfile:\nvalA, valB, srcA, srcB, dstW, valW\nin the Y86 processor: a memory with 2 ports, one for R inst, the other for R/W data\n4.3 stages of instructions Fetch PC = memaddr\nvalP = PC + len(inst)\nDecode read operands from reg file\nExecute ALU performs instruction or incr/decr the stack pointer, for other instruction, similar\nMemory W/R data in mem\nWrite back write back to register\nPC update PC stores addr of next instruction\ncost of adding hardware \u0026gt; cost of copying code in software\nprocess similar instructions in same manners\nHardware Fetch: PC computes valP, the incremented PC.\nDecode: read valA and valB\nExecute: ALU calculates integer or increments the stack pointer, decides whether jump or not.\nMemory: read or write a word of mem\nWrite Back: write back from ALU or mem\nPC update\nonly start next cycle when clock rises\nprocessor never read back\neg: no instruction will both set and read the cond code\neg: stack pointer\nfetch: fetching 6 bytes and generate instruction fields.\ndecode \u0026amp; write back: generate register identifiers, serve necessary data.\nexecute: ALU performs as the calculator or just the adder.\nmemory: write or read memory values.\nPC increment: depend on instruction code or branch or not.\nSurvey the clock must run slow enough to suit the single-cycle.\nthe parts of the processor only active for a single part of time in the clock cycle\n4.4 pipelining divide into a series of discrete stages\nincrease the throughput of a system, but slightly increase the latency\nnonpipelined: a logic performs the computation with a register hold the result of the computation\nlatency: the total time to perform a single instruction\nslowing the clock won\u0026rsquo;t change the behavior of a pipeline.\ndifferent clock delays of different instructions influences the pipeline,\ndue to the delay, pipeline doesn\u0026rsquo;t always have larger throughput with more stages on each instruction\nlogical dependencies limits the performance of pipeline\n","date":"2024-12-10T16:44:47+08:00","permalink":"https://victorzhangai.github.io/p/csapp-chapter4/","title":"Csapp Chapter4"},{"content":"VZstless as your friend or thinker 🍥 Call this name as VictorZhang was signed up by somebody else\u0026hellip; 👻 Love frontend in any perspective, digital, or web. 🐣 Libre \u0026amp; OpenSource aholic. ⭐ Still an undergraduate and a crazyone. 🐧 A human-like history book or cheatsheet. ✉️ 2319725508@qq.com 🍀I work so I live. ","date":"2024-12-09T20:45:32+08:00","permalink":"https://victorzhangai.github.io/p/whoami/","title":"Whoami"}]